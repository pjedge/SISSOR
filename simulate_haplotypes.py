 #! /usr/bin/python
# -*- coding: utf-8 -*-

'''
Created on Mon Jul  6 11:17:22 2015

@author: Peter Edge
'''

# imports
import math
import numpy as np
import os
import random

# the core function of the simulation program
def simulate_haplotypes(frag_file, vcf_file, truth_file, read_length=100000, coverage=3, ref_length=10000000, miscall_rate=0.001, missing_rate=0.01, per_frag_sw_err=0.03, snp_rate=0.0008):

    # calculate number of reads based on coverage
    # account for the fact that we'll have missing calls from missing and miscall rate
    num_reads = int(coverage * ref_length / (read_length*(1-missing_rate)*(1-2/3*miscall_rate)))
    read_length = int(read_length)

    # determine positions of SNPs
    snp_logical = np.less(np.random.random_sample(ref_length), snp_rate)   # logical array specifying occurence of SNPs or not for length of reference
    snp_ix = np.where(snp_logical)[0]                                      # indices of SNPs in reference
    num_snps = np.sum(snp_logical)                                         # total number of SNPs
    depths = [0]*num_snps

    # create random haplotypes of size num_snps
    hap1 = np.array([0]*num_snps) # first haplotype is a random 50/50 binary array
    hap2 = np.array([1]*num_snps)                                       # second hap is just first hap's complement
    haps = [hap1, hap2]

    # print haplotypes to file for comparison to assembled haplotypes later
    with open(truth_file,'w') as hf:

        print("BLOCK", file=hf)
        for i in range(0,num_snps):
            print("{}\t{}\t{}\t{}\t{}".format(i+1,int(hap1[i]),int(hap2[i]),'sim_chrom',int(snp_ix[i])),file=hf)

    with open('{}.unsorted'.format(frag_file), 'w') as ff:

        # loop and generate fragments
        for i in range(0, num_reads):
            curr_read_length = read_length
            hap_ix = random.randrange(0,2)                                 # which haplotype was fragment generated by
            start_index = random.randrange(0, ref_length-curr_read_length)      # get a random start spot
            frag_snp = np.searchsorted(snp_ix, start_index)                # find corresponding spot in snp array
            frag_snp_bak = frag_snp

            frag_indices = []
            while(frag_snp < num_snps) and (snp_ix[frag_snp] <= start_index+curr_read_length):
                frag_indices.append(frag_snp)
                frag_snp += 1

            if len(frag_indices) < 2:       # noninformative fragment, no point in continuing
                continue

            for frag_ix in frag_indices:
                depths[frag_ix] += 1

            frag = fragment()
            frag.frag_id = i
            frag.seq = bool2list(haps[hap_ix][frag_indices])

            # add switch errors to the fragment
            alpha = per_frag_sw_err / (len(frag.seq)-1) # per base switch_errors
            switched = False # currently in a "switched" state or not
            for j in range(1,len(frag.seq)):
                if random.random() < alpha:
                    print("SWITCH in fragment {} at position {}".format(i,j))
                    switched = not switched

                if switched:
                    if frag.seq[j] == '1':
                        frag.seq[j] = '0'
                    elif frag.seq[j] == '0':
                        frag.seq[j] = '1'

            frag.snp_id = frag_snp_bak + 1

            # randomly remove bases from fragment based on missing rate
            missing_vec = np.less(np.random.random_sample(len(frag.seq)), missing_rate)
            missing_indices = np.where(missing_vec)[0]

            for missing in missing_indices:
                frag.seq[missing] = '-'

            # randomly add errors to fragment based on miscall rate
            # if base is miscalled to non-ref and non-alternate, convert to '-' (thrown away)
            miscall_vec = np.less(np.random.random_sample(len(frag.seq)), miscall_rate)
            miscall_indices = np.where(miscall_vec)[0]
            extra_missing = 0
            for miscall in miscall_indices:
                # miscalled to ref or variant
                if random.randrange(0,3) == 0: # 1 in 3 chance of switching to the other base that is a ref or variant
                    if frag.seq[miscall] == '1':
                        frag.seq[miscall] = '0'
                    elif frag.seq[miscall] == '0':
                        frag.seq[miscall] = '1'
                else: # base position is thrown away, because it was miscalled to non-ref, non-alternate
                    frag.seq[miscall] = '-'
                    extra_missing +=1

            # get the ascii quality score specified by miscall rate
            q = '~' if miscall_rate < 5.011872336272714e-10 else chr(int(33-10*math.log10(miscall_rate)))
            # extend it into an array
            frag.qual = [q]*(len(frag.seq) - len(missing_indices) - extra_missing)

            # don't print an empty fragment
            if '1' not in frag.seq and '0' not in frag.seq:
                continue
            
            print_fragment(frag, ff)

    os.system('sort -n -k 3 {0}.unsorted > {0}; rm {0}.unsorted'.format(frag_file))
    
    with open (vcf_file, 'w') as vcf:
        header ='''##fileformat=VCFv4.1
##contig=<ID=sim_genome,length={}>
##INFO=<ID=mt,Number=1,Type=String,Description="Variant Type: SUBSTITUTE/INSERT/DELETE">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=FP,Number=1,Type=Integer,Description="Read Depth">
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	SIM_INDIVIDUAL'''.format(ref_length)

        # print header to vcf file
        print(header, file=vcf)

        # iterate over SNPs and print one line per SNP
        bases = ['A','T','G','C']
        for snp, genome_ix in np.ndenumerate(snp_ix):
            snp = snp[0]
            ref_ix = random.randrange(0,4)
            alt_ix = ref_ix
            while(alt_ix == ref_ix):
                alt_ix = random.randrange(0,4)

            DP = depths[snp]

            genotype_field = '1/0:{}'.format(DP)

            ref_name = 'sim_genome'
            ID = '.'
            ref_snp = bases[ref_ix]
            alt_snp = bases[alt_ix]
            qual = 100
            fltr = 'PASS'
            info = 'mt=SUBSTITUTE'
            print('{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\tGT:DP\t{}'.format(ref_name, genome_ix, ID, ref_snp, alt_snp, qual, fltr, info, genotype_field), file=vcf)

class fragment:
    frag_id = None
    snp_id = None        # index of first SNP in the fragment matrix. MUST BE 1-INDEXED
    seq = np.array([])   # fragment sequence as a numpy array
    qual = []

# convert boolean array to string of form '1001110...'
def bool2str(bool_array):
    return ''.join(str(x) for x in bool_array.astype(int))

# similar to above, except convert to list
def bool2list(bool_array):
    return [str(x) for x in bool_array.astype(int)]

# make directory, create path if necessary
def mkdir_p(path):
    if not os.path.exists(path):
        os.makedirs(path)

# print out fragment object to fragment matrix file
# frag.seq should be in
def print_fragment(frag, ff):
    # build line content

    str_qual = ''.join(frag.qual)                             # convert list to string
    blks_str = ''
    offset = frag.snp_id
    starting_new_block = True
    block_count = 0
    for x in frag.seq:
        if(x == '-'):
            offset += 1
            starting_new_block = True
            continue
        if starting_new_block:
            block_count += 1
            blks_str += ' {} '.format(offset)
            starting_new_block = False

        blks_str += x
        offset += 1


    line1 = '{} {}{} {}'.format(block_count, frag.frag_id, blks_str, str_qual)
    # print line to file
    print(line1, file=ff)
    
def main():
    simulate_haplotypes('sim_fragments','sim_variants.vcf','sim_truth.txt')

if __name__ == '__main__':
    main()
